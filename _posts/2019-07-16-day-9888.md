---
layout: post
title: "Day 9888"
date: "2019-07-16 14:43:37 +0530"
tags:
  - daily
  - laptop
---

## Morning

I woke up at 8.30 AM sharp. After that I crawled Twitter for almost 1 and half
hour. I am spending too much time on Twitter. I should quite Twitter from
Today.


## First half

While reading packaging guidelines from https://packaging.python.org, I got a
trouble, cable of my laptop charger got electric shock and it burnt. There was
no battery left. I had to book an Uber and go to SP road computer market and
buy a new cable.

Cable took 120 rupees. Cab (Uber pool) costed 89 rupees and return auto from
the market to Ulsoor metro station took 75 rupees. I spent around 284 rupees
for one cable. I took nearly two hours to go to the market and come back. What
an waste of money and time.

I could have inquired nearby computer shop and tried to get a cable. If the
cable was not solving a problem, I could have decided to get a new charger. But
instead of that, I directly went to the market.


### Factory

While going towards the market, I re-read description of Factory design pattern
from [OODesign][oodesign]. I understood a mechanism which allows to add class
registered for factory implementation without updating code of Factory method.
Yesterday I understood until the part where classes are identified via chain of
if-else statements. It was mentioned that this pattern is purely a noob pattern
and it does not convey with Open Close principle. I don't know what Open close
principle is. I will try to read it tomorrow.

As I have understood Yesterday, a factory pattern will have a method which is
responsible for creating an object of desried class. For avoid an over head of
adding new class, one should maintain a Dictionary (HashMap) at Factory class
to which new classes can be added via calling a factory method which adds an
entry to a dictionary. After that, entire codebase is dependent on method of
Factory class which is responsible to create an object of desired class.

Below is a working example of Factory in Python

```python
class ShapeFactory:

    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls, *args, **kwargs)
            cls._instance._classes = {}
        return cls._instance

    def add_class(self, key, class_name):
        self._classes[key] = class_name

    def create_object(self, key):
        _class = self._classes[key]
        return _class()


class Circle:

    def __init__(self):
        self.name = "circle"


class Triangle:

    def __init__(self):
        self.name = "triangle"


if __name__ == "__main__":
    factory = ShapeFactory()
    factory.add_class("circle", Circle)
    factory.add_class("triangle", Triangle)

    circle_1 = factory.create_object("circle")
    circle_2 = factory.create_object("circle")

    assert circle_1.name == "circle"
    assert circle_2.name == "circle"

    triangle_1 = factory.create_object("triangle")
    triangle_2 = factory.create_object("triangle")

    assert triangle_1.name == "triangle"
    assert triangle_2.name == "triangle"
```

In above example, we have to register each new type of class to a Factory
object once, but adding and new class is decoupled and following Open and Close
principle.


## Tomorrow

* Read Open close principle
* Take Circle.life 2 hour test

[OODESIGN]: https://www.oodesign.com
