---
layout: post
title: "Day 9813"
date: "2019-05-02 19:37:00 +0530"
tags:
  - daily
---

## Yoga class and a little running

Today too I missed my Yoga class. This is because I am awaking late. It is
almost constant from many days. In including Today, I have missed almost classes
more than a weak. Early sleeping and curfew on coffee will help.


## First Half

I learnt Binary Search Tree (BST). Binary Search Tree is an Data-structure
developed on top of Binary Tree. I developed insertion operation and leaves
property for my BST implementation. I solved [Sum of leaf nodes in
BST][sum_of_leaf_nodes_in_bst] problem. Please find my PR
[here][solution_pr_of_sum_of_leaf_nodes_in_bst]. In this post I will explain the
anatomy of BST and describe an algorithm to do an insertion in it.

### Binary Search Tree (BST)

Binary Search Tree is a addition over a Binary Tree. Binary Search Tree data
structure has an efficient way to traverse to a key. Below is the algorithm to
insert a key in a Binary Search Tree.

#### Insertion

```
If the Root node is empty
  Then add a Node with a given key at Root
Else
  Create a Queue
    Add a Root Node to it
  Loop while the elements in Queue is not 0
    Dequeue a Node from the Queue
    If the key of Node is less than the key
      If the Left Child of the Node is Empty
        Then create a Node with given Key, Attach it at the Left side
      Else
        Enqueue the Left child Node of the dequeued Node to the Queue
    If the key of the Node is greater than the key
      If the Right child of the Node is Empty
        Then create a Node with given Key, Attach it at the Right side
      Else
        Enqueue the Right child Node of the dequeued Node to the Queue
    If the key of the Node is same as the key
      Then increment the counter of the Node
```

The insertion operation starts with a root node of the tree. If the value of key
to be inserted is less than the key of the root node, then it will forward to
the left side of the tree. If the key to be inserted is greater than the root
key then it will forward to the right side of the root node. If both the key to
be inserted and the key of the root is same then it will increment the counter
of the root node.

Because the problem definition mentioned that the tree should be capable of
storing duplicate keys, I changed the definition of Node. I added a `counter`
attribute at the Node which is to a value 1 when the Node is initialized. The
`counter` attribute can be increased and decreased to solve the problem of
duplicate keys.

#### Leaves

I don't think there are any difference at the procedure of finding leaf nodes of
the tree. It is the same as I was doing with Binary Tree. Here the only
difference was to deal with a `counter` attribute of the Node. When I was adding
the leaf nodes, I repeat the element by its counter value.

There are other approaches to deal with duplicate keys. I decided to go with
`counter` approach because it was looking simple to me.


## Second Half

### Heap

Heap is the data structure developed especially for Heap sort algorithm. The
name Heap is not related to Garbage collector or Heap memory. Heap is binary
tree based data structure. Below are two type of Heap data structure.

* Max-heap
* Min-heap

#### Max-heap

Max-heap is a type of heap in which root element is always greater than the left
child and right child. This definition is repeated at left child and right child
and subsequently child of it until it reaches leaf nodes.

In Max heap the Parent is always greater than the left child and right child
keys. This is repeated at each node until the node is a leaf node.

In Max-heap the root element of the heap is always the maximum number from all
the given keys. The left child of root is second highest number and the right
child of the root is third highest number.

Example

```
              100
           19  |  36
        17 | 3 |25   1
      2   7|   |
```

#### Min-heap

Min heap is reverse of the Max-heap. In mean heap the root element is the
smallest key from all the nodes.

In Min-heap, the parent P is the smallest from left child and the right child.
This is repeated for all the nodes.

Example

```
            10
       14    |  19
   26  |  31 |42   27
44   35|33
```

The heap data structure is commonly used for finding an greatest or smallest
first k elements from the array. Or it is also used to short an existing array.


## Tomorrow

* Continue heap: I will complete my learning of Heap and its operations. The
method I was reading is using an `Array` data structure for storing the heap
elements. In my previous learning, I have implemented my Tree data structure
with the help of `Node` class. Where each node of the tree is an instance of
that class. A Node instance stores the value of its left and right child node.
Using array for this purpose is looking a little bit complicated. I have to
invest lot of time to understand it.

* Solve [Nearly sorted Algorithm][nearly_sorted_algorithm] based on Heap
problem.

* Learn Hash data structure. I will not use existing dictionary data structure.
I will make my own class to implement the hash data structure.

* Solve [Sum of f(a[i], a[j]) over all pairs in an array of n
integers][sum_of_over_all_pairs_in_an_array].


[sum_of_leaf_nodes_in_bst]: https://practice.geeksforgeeks.org/problems/sum-of-leaf-nodes-in-bst/1
[solution_pr_of_sum_of_leaf_nodes_in_bst]: https://github.com/ultimatecoder/geeksforgeeks/pull/14
[nearly_sorted_algorithm]: https://practice.geeksforgeeks.org/problems/nearly-sorted-algorithm/0
[sum_of_over_all_pairs_in_an_array]: https://practice.geeksforgeeks.org/problems/sum-of-fai-aj-over-all-pairs-in-an-array-of-n-integers/0
